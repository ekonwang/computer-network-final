# 传输层

提供进程间的可靠通信。

复用：应用层所有的应用进程都可以通过传输层再传输到网络层。

分用：传输层从网络层收到数据后指明的应用进程。

- **套接字与端口**

端口号是16bit数字，端口号只有<u>**本地意义**</u>。

套接字Socket = （主机ip，端口号）唯一标识了主机和其某个进程。

## UDP

*UDP只在IP数据报之上增加了很少的功能，即复用分用和<u>**差错检测**</u>的功能*。

- 主要特点

1. UDP是面向无连接的，减少开销和发送数据之前的时延。
2. UDP使用最大努力交付，即<u>**不保证**</u>可靠交付。
3. UDP是面向报文的，适合一次性传输<u>少量数据</u>的网络应用。如果UDP报文长度太大，就会导致网络层分片。
4. UDP无拥塞控制，适合很多实时应用。没有了拥塞控制，适合视频会议/直播等场景。
5. UDP的首部开销很小，只要8B，而TCP首部有20B。

<img src="https://cdn.jsdelivr.net/gh/ekonwang/images@master/img/截屏2022-01-05 下午4.16.07.png" style="zoom:33%;" />

*分用时，找不到对应的目的端口号，就丢弃报文，并向源端发送端口不可达的ICMP报文。*

- UDP 校验需要考虑虚头部

## TCP

- *面向连接的的传输层协议，连接是逻辑上的。*

- *每条TCP连接只能有两个端点。*
- *TCP 提供可靠交付的服务，无差错、不丢失、不重复、按序到达。*
- *全双工通信。*
- *面向字节流。协议只会认为数据是无意义的字节串。*

### TCP 报文段格式

<img src="https://cdn.jsdelivr.net/gh/ekonwang/images@master/img/截屏2022-01-05 下午4.28.10.png" style="zoom:25%;" />

4字节对齐的首部，最小20字节。

### TCP 连接管理

#### 三次握手

<img src="https://pic.imgdb.cn/item/61d9ab682ab3f51d913e364f.png" style="zoom: 67%;" />

通常在第三次握手时，数据就可以发送了。

#### 四次挥手

TCP 连接被看成由两个方向的单工连接组成，在释放时，两个方向的连接都应该要关闭。

- 信息传输完毕的一方发送一个 FIN 标志，表示没有数据要发送，当 FIN 被确认以后，那个方向的连接就被关闭；
- 只有当两个方向的连接都被关闭之后，该 TCP 连接才被完全释放；
- TCP 连接释放也可以看作三次握手过程：把一个FIN 和 ACK 合并，就是三次握手的过程。

<img src="https://pic.imgdb.cn/item/61d9acb52ab3f51d913f33bc.png" style="zoom:50%;" />

主动释放的一端最后要进入 TIME-WAIT 状态

- 需要维护连接状态 2*MSL (Maximum Segment Lifetime——最大报文段生存时间)
- 在 C/S 模式中一般由**客户方**主动释放连接



### TCP 可靠传输

*可靠：保证接收方进程从缓冲区读出的字节流与发送方发出的字节流是完全一样的。*

*累计确认：只发送目前未收到的最小序列。*

*捎带确认：确认和数据一起被接收方发送。*

#### 重传与 TCP 计时器

确认机制和重传机制关系密切，TCP的发送方在<u>**规定时间内**</u>没有收到确认，就要重发已发送的报文段。

TCP采用自适应的算法，动态改变重传时间RTTs。

计算超时间隔的算法:
$$
Timeout ~=~ EstimatedRTT + 4~Deviation 
$$

$$
EstimatedRTT = \alpha EstimatedRTT + (1-\alpha)SampleRTT
$$

$$
Deviation = (1-x)Deviation + x(|EstimatedRTT-SampleRTT|)
$$

*注意这里 $\alpha$在公式(2)中是momentum参数, 而 $(1-x)$在公式(3) 中才是momentum参数.* 

##### 冗余ACK与快速重传机制（冗余确认）

每当比期望序列更大的失序报文段到达时，就发送一个冗余ACK，指明下一个期待字节的序号。冗余确认到达一定上限，就快速重传<u>不再等待超时</u>。

一个例子：

<img src="https://cdn.jsdelivr.net/gh/ekonwang/images@master/img/截屏2022-01-05 下午5.12.12.png" style="zoom:35%;" />

### TCP 流量控制

==流量控制和拥塞控制是TCP考察的重点==

流量控制:让发送方发送得慢一点, 让接收方来得及接收. 

TCP利用滑动窗口实现流量控制. 在通信过程中, 接收方根据自己接收缓存的大小, 动态地调整发送方的发送窗口大小, 即接收窗口 rwnd, 发送方的发送窗口取接收窗口rwnd和拥塞窗口cwnd的最小值. 

**即通过动态调整发送窗口控制流量.**

<u>**一个需要解决的问题: 0接收窗口**</u>

<img src="https://cdn.jsdelivr.net/gh/ekonwang/images@master/img/截屏2022-01-05 下午5.42.01.png" style="zoom:25%;" />

如图所示, 接收方0窗口后, 发送方将停止发送数据帧, 若之后接收方的接收窗口不再为0, 它又不向发送方发送任何数据了, <u>发送方就一直以为rwnd 为0</u>, 进而一直不发送数据. 为了解决该问题, 只要TCP一方的收到对方的零窗口通知, 就设置一个计时器, 若计时器到期, 就发送一个数据长度为1的<u>探测报文段</u>. 如果依然为0, 就重新设置计时器, 如果不为0 ? 那就继续正常发送数据.

### 拥塞控制

对于拥塞的条件: 对资源需求的总和 > 可用资源

网络上有许多资源同时呈现出供应不足 $\rightarrow$ 网络性能变坏 $\rightarrow$ 网络吞吐量随输入负荷增大而下降.

> 拥塞控制 v.s. 流量控制
>
> 和流量控制不同, 拥塞控制可以用下面第一张图描述其差异. 二者的关键在于拥塞控制解决“全局性”的问题. 
>
> <img src="https://cdn.jsdelivr.net/gh/ekonwang/images@master/img/截屏2022-01-05 下午10.05.45.png" style="zoom:25%;" />

#### 慢开始算法&拥塞避免

*一个传输轮次: 一个RTT的时间*

在ssthresh之前, 二指数增长拥塞窗口. 

在到达ssthresh 之后, 采用加法增大策略.

出现网络拥塞, <u>ssthresh 变为此时的一半, 拥塞窗口变为1</u>, 开始新的慢开始过程.

> 为什么叫做慢开始? 拥塞窗口的初始大小仅为1
>
> TCP Tahoe 版本采用该算法, 但该算法已经被弃用, TCP 的reno 版本采用快重传方案

<img src="https://cdn.jsdelivr.net/gh/ekonwang/images@master/img/截屏2022-01-05 下午10.11.03.png" style="zoom:35%;" />

#### 快重传&快恢复

快重传 : 回忆一下冗余 ACK 机制, 当发送者发送同一个 ACK 大于或等于 3 次之后, 直接进入快恢复状态, 而不用等到检测到拥塞.

快恢复: 出现拥塞之后, 直接到新的 sshthresh 拥塞窗口大小并进入拥塞避免状态.   

<img src="https://cdn.jsdelivr.net/gh/ekonwang/images@master/img/截屏2022-01-05 下午10.19.20.png" style="zoom:33%;" />

#### 空闲后的拥塞窗口

TCP 连接空闲较长一段时间之后，在重新开始传输数据时进入如同拥塞后的慢启动过程。

<img src="https://pic.imgdb.cn/item/61d9bbf52ab3f51d914a3c38.png" style="zoom: 50%;" />



## 传输层总结



<img src="https://cdn.jsdelivr.net/gh/ekonwang/images@master/img/截屏2022-01-05 下午10.25.42.png" style="zoom:40%;" />



<img src="https://cdn.jsdelivr.net/gh/ekonwang/images@master/img/截屏2022-01-05 下午10.29.59.png" style="zoom:33%;" />

